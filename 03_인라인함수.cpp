#include <iostream> 
using namespace std;

// 전처리문은 #으로 시작

// 전처리문이란?
// 실제 컴파일이 시작되 기 전에, 컴파일러에게
// 특별한 명령을 미리 처리하도록 지시할 때 사용하는 구문
// 한 라인에 한 개의 전처리기 명령만을 사용
// 만약 여러 줄의 명령을 처리하도록 하려면 \ 를 이용하여
// 여러 줄로 작성 가능
// 전처리기 지시어는 끝에 세미콜론을 붙이지 않습니다.

// 심볼, 매크로 상수/함수를 정의할 때

// #define : 심볼 또는 매크로 상수/함수를 정의

// 심볼 TEST를 정의
// -> 심볼을 정의하고, 특정 심볼이 존재할 때에만 특정 코드가 
//    컴파일에 포함되도록 설정할 수 있다.
#define TEST

// 매크로 상수
#define PI 3.14f
// 3.14f를 PI 키워드로 정의합니다.
// 사용한다면 PI가 3.14f 라는 코드로 치환

// 매크로 함수
#define Plus(x, y) (x + y)
// x + y 코드를 Plus(x, y)로 정의합니다.
// 사용한다면 Plus(x, y) 코드가 x + y 라는 코드로 치환되므로
// 매크로 함수는 일반 함수처럼 코드 점프가 일어나지 않으므로
// 처리속도가 훨씬 빠릅니다.
// -> 비교적 함수의 내용이 간결하고, 프로그램 내에서 자주 사용한다면
//    매크로 함수로 만들어서 처리

// 인라인 함수
// 짧은 코드로 구성된 함수에 대해 "함수 호출 오버헤드"로 인한
// 프로그램의 실행 속도 저하를 줄이기 위해 사용

// 함수 호출 오버헤드
// 프로그램의 실행 흐름 도중에 다른 위치에 있는 코드를 실행시켜야 할 때
// 추가적으로 시간과 메모리가 사용되는 현상을 의미
// 만약 굉장히 간단한 코드라면 내용 실행보다, 호출 준비 시간이
// 더 오래 걸릴 수 있음
// 이러한 현상을 줄이기 위하여, 매크로 함수/인라인 함수를 사용하여 최적화

// 매크로 함수 장점
// 일반 함수에 비해 실행속도가 빠르다 <- 그대로 유지
// 매크로 함수 단점
// 반환 타입 지정 불가능, 매개변수 타입 지정 불가능 <- 최대한 제거
// -> 매크로의 장점은 살리고, 단점은 제거한 것이 인라인 함수

// 매크로 함수는 전처리기에 의해서 처리되지만
// 인라인 함수는 컴파일러에 의해 처리
// 인라인 함수는 인라인화가 오히려 성능에 해가 된다고
// 컴파일러가 판단할 경우, 인라인 함수를 일반 함수처럼 처리하기도 하며
// 일반 함수도 필요한 경우 임의로 인라인 처리될 수 있습니다.


 
